\section{Discussion}
\label{sec:discussion}

There are two aspects of scalability in program repair algorithms: scaling to large programs and scaling to large search spaces of patches. The scalability of our solution to large programs depends on the scalability of the underlying termination analysis. Our technique scales precisely to the programs that are supported by LinearRankTerm and RankFinder. The scalability to search spaces depends on (1) the ability of the SMT solver to solve constraints generated by the termination prover, which in turn depends on the complexity of the program, and (2) on the scalability of the synthesis algorithm. The longest program we analysed and generated a correct patch for is 56 LoC (Missing\_Iterator\_Update\_2), and the most complex patch we synthesised is a linear combination of five program variables. There is evidence that termination errors can often be fixed by small code modifications. For example, among the termination bugs systematically extracted by Shi et al. \sergey{cite} from popular open source projects, 41\% are fixed by the developers by adding or modifying only a single line, and 20\% by adding or modifying several adjacent lines. We will clarify this in the paper. \sergey{integrate this text}


In this work, we focused on single-line changes for the following reasons. First, termination errors can often be fixed by small changes, e.g. among the termination bugs systematically extracted by Shi et al.\sergey{cite} from popular open source projects, 41\% are fixed by the developers by adding or modifying only a single line. Apart from that, focusing on smaller changes helps to avoid the generation of incorrect patches, as was observed by Mechtaev at al\sergey{cite}. In future work, we will investigate how to support multi-line patches, for which we will need to address the problem of finding a tight approximation of the expressions that should be simultaneously modified to repair the bug to preserve scalability. \sergey{integrate this text}
