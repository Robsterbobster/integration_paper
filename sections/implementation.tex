\section{Implementation}
\label{sec:implementation}


\begin{figure}[t]
	\centering
    \scalebox{0.9}{\input{architecture.pdf_tex}}
	\caption{Architecture of \projName.}
	\label{fig:architecture}
\end{figure}


\projName is implemented in Python for C programs. Its architecture is shown in \Cref{fig:architecture}. First, \projName iterates through all suspicious expressions in the program, \ie those on which the loop condition is data- or control-dependent. It replaces each of the suspicious expression with $\rho$ applied to visible program variables. Currently, we only use local variables defined in the same function as the suspicious expression. Then, \projName executes \dtaRepair that internally uses \rfsRepair to generate repair constraints $\phi$. The constraints are solved using a CEGIS implemented on top Z3~\cite{deMoura2008Z3}. After that, we apply our patch prioritisation heuristics to rank the patches and present the top $N$ of them ($N$ is configurable) to the user.

The current implementation has several limitations. First, since we rely on linear ranking function synthesis, \projName only handles linear integer programs. It does not support operations such as multiplication between variables. Second, the implementation does not support user-defined data structures, arrays, and pointers. Third, user-defined functions are currently supported through inlining and recursive functions are not supported. In principle, these limitations can be addressed by employing existing techniques~\cite{magill2007arithmetic}, however this is out of scope of this study. We plan to address them in future works. \sergey{We should discuss in more detail how to overcome these limitations.}
