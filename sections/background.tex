\section{Background on Termination Proving}
\label{sec:background}

We consider imperative programs using variables $V$ with the following statements: assignments $x:=e$, assume statements $\mathrm{assume}(b)$, sequences $c_1; c_2$ of statements $c_1$ and $c_2$, non-deterministic choices $c_1\,[]\,c_2$, and while loops $\mathrm{while}(b)\ c$. A \emph{program state} $S$ is a mapping from variables $V$ to values. We formalise a program's semantics as a \emph{transition system} defined via an \emph{update relation}, which we denote using constraints over \emph{un-primed} and \emph{primed} variables that indicate the previous and the next values of variables, \eg $[x' = x + 1]$ is the semantics of a program that increments the variable $x$. A \emph{transition relation} is a subset of the update relation that only includes those states reachable from a given set of initial states.

We use the notation $C[Y/X]$ to indicate the substitution of $X$ with $Y$ in $C$. $R(I)$ denotes the \emph{image} of the relation $R$ on $I$. $R_1; R_2$ is a \emph{relational composition}. $R^*$ and $R^+$ are \emph{reflexive and non-reflexive transitive closures}. The structure $(S, \ge)$ forms a \emph{well order} iff it is a total order and every nonempty subset of $S$ has a least element. A sequence of states $s \triangleq s_1, s_2, ...$ is permitted by $R$ if $\forall i.\ R(s_i, s_{i+1})$. A binary relation is \emph{well-founded} iff it does not permit infinite sequences. A \emph{ranking function} is a mapping with a range to a well-ordered set.

To prove that a program terminates is to prove that its transition relation is well-founded. A popular approach of proving that a relation $R$ is well-founded is finding a ranking function defined on program states, so that the relation it induces on states is a superset of $R$. Constructing a ranking function for a complex relation can be challenging. To address this problem, the disjunctive well-foundedness principle~\cite{podelski2004Ti} can be used to split the problem into simpler subtasks. It states that it is sufficient to check that the non-reflexive transitive closure of $R$ is included in the union of a finite set of well-founded relations (\Cref{eq:disjunctive}).

\subsection{Synthesising Linear Ranking Functions with \rfs}
\label{sec:rfs}

To find a ranking function for a loop, \rfs~\cite{podelski2004lrf} creates a system of linear inequalities. Solving this system with, \eg, an SMT solver, provides solutions that represent linear ranking functions for the loop. The algorithm accepts a program whose transition relation can be expressed by a system of inequalities in the form:
\begin{equation}\label{eq:rfs_transition}
\begin{pmatrix}
HH^\prime
\end{pmatrix}
\begin{pmatrix}
x\\x^\prime
\end{pmatrix} \le  b
\end{equation}
\noindent where $x$ and $x^\prime$ are vectors of un-primed and primed variables in the program, $H$ and $H^\prime$ are vectors of coefficients, and $b$ represents a vector of integer constants. Only simple programs can be represented using such system, which highlights the main limitation of this approach. The values $H$, $H^\prime$ and $b$ encode the semantics of this program. We omit the algorithm of computing these values, since it is non-essential for \projName.

The authors of \rfs prove that, given the above transition system, the existence of a ranking function can be checked by solving the following system over vectors of rationals $\lambda_1, \lambda_2$:
\begin{align*}
&\lambda_1, \lambda_2 \ge 0\\
&\lambda_1 H^\prime = 0\\
&(\lambda_1 - \lambda_2)H = 0\\
&\lambda_2 (H+H^\prime) = 0\\
&\lambda_2 b < 0
\end{align*}

If a solution of this system exists, say, $\lambda_1$ and $\lambda_2$, \rfs defines the ranking function as
\begin{equation}
  f(x) \triangleq
    \begin{cases}
      rx & \text{if exists $x'$ such that $\begin{pmatrix} HH^\prime \end{pmatrix} \begin{pmatrix} x\\x^\prime \end{pmatrix} \le  b$}\\
      \delta_0 - \delta & \text{otherwise}
    \end{cases}       
\end{equation}
\noindent where $r \triangleq \lambda_2 H'$, $\delta_0 \triangleq -\lambda_1 b$, and $\delta \triangleq -\lambda_2 b$. The ``otherwise'' case is enabled after the loop finishes iterations. This case is handled separately by \dta (\Cref{sec:dta}) and our approach, therefore we ignore it in subsequent definitions.

\subsection{Automation of The Disjunctive Well-Foundedness Principle in \dta}
\label{sec:dta}

\dta is Chawdhary~\etal~\cite{chawdhary2008ra}'s automation of the disjunctive well-foundedness principle based on abstract interpretation. It uses a domain $D$ of relations expressed via linear constraints $C$ over un-primed, primed and, additionally, double-primed variables that denotes values which were once stored in program variables during computation. The concretisation function defined as $$\gamma(C) \triangleq \{(s_0, s_1)\mid (s_0, s'_1 \models \exists X''.C)\},$$ where $X''$ are all double-primed variables. $D$ contains an abstract identity element $d_\mathrm{id} \triangleq \bigwedge_{x\in V} x = x'$. \dta uses an operator $\mathrm{RFS}: D \rightarrow 2^D \cup \{ \top \}$ to overapproximate its argument by generating a ranking function using \rfs or $\top$ if \rfs fails. Specifically, it constructs constraints $$T_{E} \triangleq (E \ge 0 \wedge E - 1 \ge E')$$ for an expression $E$ representing the ranking function ($E'$ is $E$ with all variables replaced with their primed versions). These constraint is an overapproximation of $\mathrm{RFS}$'s argument $C$ in the sense that $(\exists X''. C) \Rightarrow T_{E,q}$. The approach uses an abstract composition function is defined as
\begin{align*}
  \mathrm{comp}(C_0, C_1) \triangleq\ &\mathtt{let}\ C_2 = \mathrm{fresh}(C_1)\\
  &\mathtt{in}\ C_0[Y''/V'] \wedge C_2[Y''/V],
\end{align*}
\noindent where $\mathrm{fresh}$ renames all double-primed variables in the constraint fresh, and $Y''$ is a set of fresh double-prime variables.

\dta analyser is then defined as
\begin{align*}
  &\llbracket x:=e \rrbracket^\# C \triangleq \{ C[x''/x'] \wedge x' = e[x''/x]\}\quad x''\text{ is fresh}\\
  &\llbracket \mathrm{assume}(b) \rrbracket^\# C \triangleq \mathtt{if}\ (C \wedge b \vdash \mathrm{false})\ \mathtt{then}\ \{\}\\
  &\quad\quad \mathtt{else}\ \{\,C_0, ..., C_n \mid C_0 \vee ... \vee C_n = \mathrm{DNF}(C \wedge b)\,\}\\
  &\llbracket c_0; c_1 \rrbracket^\# C \triangleq (\llbracket c_1 \rrbracket^\# \circ \llbracket c_0 \rrbracket^\#) C\\
  &\llbracket c_0\,[]\,c_1 \rrbracket^\# C \triangleq \llbracket c_0 \rrbracket^\# C \cup \llbracket c_1 \rrbracket^\# C\\
  &\llbracket \mathrm{while}(b)\ c \rrbracket^\# C \triangleq\\
  &\quad\quad \mathtt{let}\ F \triangleq \lambda A'.\ \llbracket \mathrm{assume}(b);\ c \rrbracket^\# (d_\mathrm{id} \cup A')\\
  &\quad\quad \mathtt{in}\ \llbracket \mathrm{assume}(\neg b) \rrbracket^\# (\mathrm{comp}^\dagger(A, \mathrm{fix}(\mathrm{RFS}^\dagger \circ F)))
\end{align*}
\noindent where $\mathrm{DNF}$ computes the disjunctive normal form, functions marked with $\dagger$ are extended so that they return $\top$ if one of their arguments is $\top$, and $\mathrm{fix}$ is a fixpoint operators that computes the sequence $\{G_n\}_n$ such that $G_0 = \{\}$ and $G_{n+1} = G_n \cup (\mathrm{RFS}^\dagger \circ F)(G_n)$ until it finds $G_n$ such that $G_n=\top$ or
\begin{equation}\label{eq:fixpoint}
  G_n\neq\top \wedge G_{n+1}\neq\top \wedge \forall C\in G_{n+1}.\ \exists C'\in G_n.\ C\vdash C'.
\end{equation}

Given a program $c$, \dta computes $\llbracket c \rrbracket^\#(d_\mathrm{id})$ and if the result is not $\top$, then $c$ terminates.
